"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var utils_1 = require("../utils");
var RedisBotStorage = (function () {
    function RedisBotStorage(redisClient, settings) {
        this.redisClient = redisClient;
        this.settings = settings;
        var ttl = (settings || {}).ttl;
        if (!redisClient) {
            throw new Error("Invalid constructor arguments for the RedisBotStorage class.");
        }
        if (ttl) {
            if (!utils_1.validateTTLSettings(ttl)) {
                throw new Error("Invalid TTL settings.");
            }
            else {
                this.ttl = ttl;
            }
        }
    }
    RedisBotStorage.prototype.getData = function (context, callback) {
        var _this = this;
        var readOps = [];
        var data = {};
        var userId = context.userId, conversationId = context.conversationId, persistUserData = context.persistUserData, persistConversationData = context.persistConversationData;
        if (userId) {
            if (persistUserData) {
                readOps.push({
                    key: "userData:user:" + userId,
                    type: "userData",
                });
            }
            if (conversationId) {
                readOps.push({
                    key: "privateConversationData:user:" + userId + ":conversation:" + conversationId,
                    type: "privateConversationData",
                });
            }
        }
        if (persistConversationData && conversationId) {
            readOps.push({
                key: "conversationData:conversation:" + conversationId,
                type: "conversationData",
            });
        }
        Promise.all(readOps.map(function (entry) {
            return new Promise(function (resolve, reject) {
                var key = entry.key, type = entry.type;
                _this.redisClient.get(key, function (err, res) {
                    if (err) {
                        return reject(err);
                    }
                    res = res || "{}#";
                    var _a = res.split("#"), obj = _a[0], hash = _a[1];
                    var hashKey = type + "Hash";
                    data[type] = JSON.parse(obj);
                    data[hashKey] = hash;
                    resolve();
                });
            });
        })).then(function () {
            callback(null, data);
        }).catch(function (error) {
            callback(error, {});
        });
    };
    RedisBotStorage.prototype.saveData = function (context, data, callback) {
        var _this = this;
        var writeOps = [];
        var userId = context.userId, conversationId = context.conversationId, persistUserData = context.persistUserData, persistConversationData = context.persistConversationData;
        var addWrite = function (type, key, state, prevHash) {
            state = JSON.stringify(state || {});
            var hash = crypto_1.createHash("sha256").update(state);
            var newHash = hash.digest("hex");
            if (newHash !== prevHash) {
                var writeOperation = {
                    key: key,
                    value: state + "#" + newHash,
                };
                if (_this.ttl) {
                    writeOperation.expireAt = _this.ttl[type];
                }
                writeOps.push(writeOperation);
            }
        };
        addWrite = addWrite.bind(this);
        if (userId) {
            if (persistUserData) {
                var id = "userData";
                var key = id + ":user:" + userId;
                addWrite(id, key, data.userData, data.userDataHash);
            }
            if (conversationId) {
                var id = "privateConversationData";
                var key = id + ":user:" + userId + ":conversation:" + conversationId;
                var d = data.privateConversationData, h = data.privateConversationDataHash;
                addWrite(id, key, d, h);
            }
        }
        if (persistConversationData && conversationId) {
            var id = "conversationData";
            var key = id + ":conversation:" + conversationId;
            var d = data.conversationData, h = data.conversationDataHash;
            addWrite(id, key, d, h);
        }
        Promise.all(writeOps.map(function (entry) {
            return new Promise(function (resolve, reject) {
                var key = entry.key, value = entry.value, expireAt = entry.expireAt;
                var callback = function (err) {
                    if (err) {
                        return reject(err);
                    }
                    resolve();
                };
                var args = [key, value, callback];
                if (expireAt) {
                    args.splice(2, 0, "EX", expireAt);
                }
                (_a = _this.redisClient).set.apply(_a, args);
                var _a;
            });
        })).then(function () {
            callback(null);
        }).catch(function (error) {
            callback(error);
        });
    };
    return RedisBotStorage;
}());
exports.RedisBotStorage = RedisBotStorage;
//# sourceMappingURL=RedisBotStorage.js.map